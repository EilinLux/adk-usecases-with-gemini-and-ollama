# ‚ö° Parallel Research & Synthesis System

This project implements a **Fan-Out / Fan-In Architecture** using the Google Agent Development Kit (ADK). It demonstrates how to significantly reduce execution time by running multiple autonomous agents simultaneously (`ParallelAgent`) before synthesizing their results with a final coordinator (`SequentialAgent`).

## üèóÔ∏è System Architecture

This system allows for "Team-based" execution. Instead of waiting for one research task to finish before starting the next, three specialized researchers work at the same time.

**The Workflow:**

1.  **Fan-Out (Parallel Phase):** The system triggers the `Tech`, `Health`, and `Finance` agents simultaneously. They all search the web and generate reports in parallel.
2.  **State Sync:** As each agent finishes, it writes its specific report to the shared session memory (`tech_research`, `health_research`, `finance_research`).
3.  **Fan-In (Aggregation Phase):** Once *all* parallel agents are finished, the `AggregatorAgent` activates. It reads all three reports from memory and produces a final executive summary.

## üìÇ Component Breakdown

### 1\. The Researchers (The Parallel Team)

These three agents are identical in structure but specialized in instruction.

  * **TechResearcher:** Scans for AI/ML trends.
  * **HealthResearcher:** Scans for medical breakthroughs.
  * **FinanceResearcher:** Scans for fintech innovations.
  * **Key Feature:** They all use the `Google Search` tool and have distinct `output_key`s.

### 2\. The Controller: `ParallelAgent`

  * **Name:** `parallel_research_team`
  * **Role:** The Async Manager.
  * **Why use it?** If you used a `SequentialAgent` here, the system would take roughly **3x longer** to run because it would wait for Tech to finish before starting Health. `ParallelAgent` executes them concurrently.

### 3\. The Synthesizer: `AggregatorAgent`

  * **Role:** The Editor-in-Chief.
  * **Why use it?** Raw data from three different sources is hard to consume. This agent acts as a bottleneck that unifies the voice and format.
  * **Data Access:** It uses **Context Injection**. The instruction contains placeholders like `{tech_research}`. The ADK automatically fills these with the text generated by the parallel team.

### 4\. The Orchestrator: `SequentialAgent`

  * **Name:** `root_agent`
  * **Role:** The Timeline Manager.
  * **Logic:** It ensures the `ParallelResearchTeam` completes **100%** of its work before the `AggregatorAgent` is allowed to start. If the Aggregator started too early, the variables `{tech_research}` etc., would be empty.

## üöÄ How to Run

### Setup

Ensure your environment variables are set:

```bash
export GOOGLE_API_KEY="your_actual_api_key"
```

### Execution

**Option 1: ADK Web (Visual)**
Run this command to see the parallel execution bars in the UI:

```bash
adk web .
```

*Note: In the Web UI, you might see the "Thinking" indicators for the three agents appear simultaneously.*

**Option 2: Python Script**
Append this code to your file to run it as a standalone script:

```python
if __name__ == "__main__":
    print("üöÄ Starting Parallel Research System...")
    # The prompt here is less relevant because the agents have specific instructions,
    # but we pass a generic trigger.
    result = runner.run("Generate the executive summary.")
    
    print("\n" + "="*40)
    print("      EXECUTIVE SUMMARY")
    print("="*40 + "\n")
    print(result.text)
```